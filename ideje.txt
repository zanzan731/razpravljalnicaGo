2. Pri verižni replikaciji morajo itak imet vsi enake podatke, zato lahko samo
vsak server pokliče isto funkcijo na naslednjem (createUser, createTopic,...).
Kličejo se rekurzivno, da se potrditev pravilno širi.
Pri repu se ustavi in se v drugo smer pošlje potrditev te verzije podatkov.

Problem je, ker moramo za vse to imeti version control, da vemo ali lahko
na tem serverju beremo (če ima zadnjo potrjeno verzijo).
messageIdVer = make(map[Int64](Int64, bool))
... // ne vem, če je tu prou
oz. strukturam dodamo verzijo? Ker kao lahko urejamo vmesnik.

Glava-...-A-B-C-...-Rep
Če B odpove, mora C A-ju poslat številko zadnjega podatka, ki ga ima potrjenega,
zato da mu A pošlje kar manjka. A pa mora C-ju poslat številko zadnje potrditve,
da mu C lahko pošlje manjkajoče potrditve.<-TO DVOJE SE MENITA PREKO NADZORNE PLASTI

- Če user ni dobil potrditve o zapisu še enkrat pošlje zahtevo po
preteku časa. (Ali uporabiš context timer na glavi in pošlješ error, če ni bilo potrditve?
Ali bo vedno dobil potrditev, zaradi nadzorne plasti?)

4. Dodajanje vozlišč na rep:
- Šele ko rep prepiše vse svoje podatke na novo vozlišče, to postane nov rep. (ena gorutina prepisuje?)

5. Nadzorna plast mora biti odporna na napake
- Uporabimo Raft, ki je nekje že spisan.